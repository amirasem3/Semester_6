// Copyright (C) 1991-2015 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus Prime License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "05/16/2019 14:36:29"
                                                                                
// Verilog Test Bench (with test vectors) for design :                          PC
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module PC_vlg_vec_tst();
// constants                                           
// general purpose registers
reg Branch;
reg [15:0] BranchOffset;
reg CLK;
reg Jump;
reg [25:0] JumpAddress;
reg Reset;
// wires                                               
wire PC0;
wire PC1;
wire PC2;
wire PC3;
wire PC4;
wire PC5;
wire PC6;
wire PC7;
wire PC8;
wire PC9;
wire PC10;
wire PC11;
wire PC12;
wire PC13;
wire PC14;
wire PC15;
wire PC16;
wire PC17;
wire PC18;
wire PC19;
wire PC20;
wire PC21;
wire PC22;
wire PC23;
wire PC24;
wire PC25;
wire PC26;
wire PC27;
wire PC28;
wire PC29;
wire PC30;
wire PC31;

// assign statements (if any)                          
PC i1 (
// port map - connection between master ports and signals/registers   
	.Branch(Branch),
	.BranchOffset(BranchOffset),
	.CLK(CLK),
	.Jump(Jump),
	.JumpAddress(JumpAddress),
	.PC0(PC0),
	.PC1(PC1),
	.PC2(PC2),
	.PC3(PC3),
	.PC4(PC4),
	.PC5(PC5),
	.PC6(PC6),
	.PC7(PC7),
	.PC8(PC8),
	.PC9(PC9),
	.PC10(PC10),
	.PC11(PC11),
	.PC12(PC12),
	.PC13(PC13),
	.PC14(PC14),
	.PC15(PC15),
	.PC16(PC16),
	.PC17(PC17),
	.PC18(PC18),
	.PC19(PC19),
	.PC20(PC20),
	.PC21(PC21),
	.PC22(PC22),
	.PC23(PC23),
	.PC24(PC24),
	.PC25(PC25),
	.PC26(PC26),
	.PC27(PC27),
	.PC28(PC28),
	.PC29(PC29),
	.PC30(PC30),
	.PC31(PC31),
	.Reset(Reset)
);
initial 
begin 
#1000000 $finish;
end 

// Reset
initial
begin
	Reset = 1'b0;
	Reset = #20000 1'b1;
	Reset = #860000 1'b0;
end 

// CLK
always
begin
	CLK = 1'b0;
	CLK = #10000 1'b1;
	#10000;
end 

// Branch
initial
begin
	Branch = 1'b0;
	Branch = #100000 1'b1;
	Branch = #100000 1'b0;
end 

// Jump
initial
begin
	Jump = 1'b0;
	Jump = #200000 1'b1;
	Jump = #120000 1'b0;
end 
// BranchOffset[ 15 ]
initial
begin
	BranchOffset[15] = 1'b0;
end 
// BranchOffset[ 14 ]
initial
begin
	BranchOffset[14] = 1'b0;
end 
// BranchOffset[ 13 ]
initial
begin
	BranchOffset[13] = 1'b0;
end 
// BranchOffset[ 12 ]
initial
begin
	BranchOffset[12] = 1'b0;
end 
// BranchOffset[ 11 ]
initial
begin
	BranchOffset[11] = 1'b0;
end 
// BranchOffset[ 10 ]
initial
begin
	BranchOffset[10] = 1'b0;
end 
// BranchOffset[ 9 ]
initial
begin
	BranchOffset[9] = 1'b0;
end 
// BranchOffset[ 8 ]
initial
begin
	BranchOffset[8] = 1'b0;
end 
// BranchOffset[ 7 ]
initial
begin
	BranchOffset[7] = 1'b0;
end 
// BranchOffset[ 6 ]
initial
begin
	BranchOffset[6] = 1'b0;
end 
// BranchOffset[ 5 ]
initial
begin
	BranchOffset[5] = 1'b0;
end 
// BranchOffset[ 4 ]
initial
begin
	BranchOffset[4] = 1'b1;
	BranchOffset[4] = #400000 1'b0;
end 
// BranchOffset[ 3 ]
initial
begin
	BranchOffset[3] = 1'b0;
end 
// BranchOffset[ 2 ]
initial
begin
	BranchOffset[2] = 1'b1;
	BranchOffset[2] = #400000 1'b0;
end 
// BranchOffset[ 1 ]
initial
begin
	BranchOffset[1] = 1'b0;
end 
// BranchOffset[ 0 ]
initial
begin
	BranchOffset[0] = 1'b0;
end 
// JumpAddress[ 25 ]
initial
begin
	JumpAddress[25] = 1'b0;
end 
// JumpAddress[ 24 ]
initial
begin
	JumpAddress[24] = 1'b0;
end 
// JumpAddress[ 23 ]
initial
begin
	JumpAddress[23] = 1'b0;
end 
// JumpAddress[ 22 ]
initial
begin
	JumpAddress[22] = 1'b0;
end 
// JumpAddress[ 21 ]
initial
begin
	JumpAddress[21] = 1'b0;
end 
// JumpAddress[ 20 ]
initial
begin
	JumpAddress[20] = 1'b0;
end 
// JumpAddress[ 19 ]
initial
begin
	JumpAddress[19] = 1'b0;
end 
// JumpAddress[ 18 ]
initial
begin
	JumpAddress[18] = 1'b0;
end 
// JumpAddress[ 17 ]
initial
begin
	JumpAddress[17] = 1'b0;
end 
// JumpAddress[ 16 ]
initial
begin
	JumpAddress[16] = 1'b0;
end 
// JumpAddress[ 15 ]
initial
begin
	JumpAddress[15] = 1'b0;
end 
// JumpAddress[ 14 ]
initial
begin
	JumpAddress[14] = 1'b0;
end 
// JumpAddress[ 13 ]
initial
begin
	JumpAddress[13] = 1'b0;
end 
// JumpAddress[ 12 ]
initial
begin
	JumpAddress[12] = 1'b0;
end 
// JumpAddress[ 11 ]
initial
begin
	JumpAddress[11] = 1'b0;
end 
// JumpAddress[ 10 ]
initial
begin
	JumpAddress[10] = 1'b0;
end 
// JumpAddress[ 9 ]
initial
begin
	JumpAddress[9] = 1'b1;
	JumpAddress[9] = #280000 1'b0;
end 
// JumpAddress[ 8 ]
initial
begin
	JumpAddress[8] = 1'b1;
	JumpAddress[8] = #400000 1'b0;
end 
// JumpAddress[ 7 ]
initial
begin
	JumpAddress[7] = 1'b1;
	JumpAddress[7] = #400000 1'b0;
end 
// JumpAddress[ 6 ]
initial
begin
	JumpAddress[6] = 1'b1;
	JumpAddress[6] = #400000 1'b0;
end 
// JumpAddress[ 5 ]
initial
begin
	JumpAddress[5] = 1'b1;
	JumpAddress[5] = #400000 1'b0;
end 
// JumpAddress[ 4 ]
initial
begin
	JumpAddress[4] = 1'b0;
	JumpAddress[4] = #280000 1'b1;
	JumpAddress[4] = #120000 1'b0;
end 
// JumpAddress[ 3 ]
initial
begin
	JumpAddress[3] = 1'b1;
	JumpAddress[3] = #280000 1'b0;
end 
// JumpAddress[ 2 ]
initial
begin
	JumpAddress[2] = 1'b0;
	JumpAddress[2] = #280000 1'b1;
	JumpAddress[2] = #120000 1'b0;
end 
// JumpAddress[ 1 ]
initial
begin
	JumpAddress[1] = 1'b0;
end 
// JumpAddress[ 0 ]
initial
begin
	JumpAddress[0] = 1'b0;
end 
endmodule

