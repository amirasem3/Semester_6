// Copyright (C) 1991-2015 Altera Corporation. All rights reserved.
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, the Altera Quartus Prime License Agreement,
// the Altera MegaCore Function License Agreement, or other 
// applicable license agreement, including, without limitation, 
// that your use is for the sole purpose of programming logic 
// devices manufactured by Altera and sold by Altera or its 
// authorized distributors.  Please refer to the applicable 
// agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "06/07/2019 21:09:29"
                                                                                
// Verilog Test Bench (with test vectors) for design :                          testing_DP
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module testing_DP_vlg_vec_tst();
// constants                                           
// general purpose registers
reg [2:0] ALU_OP;
reg CLK;
reg CLR;
reg EN_A;
reg EN_ALUOUT;
reg EN_B;
reg EN_HIGH;
reg EN_IR_HIGH;
reg EN_IR_LOW;
reg EN_LOW;
reg EN_MDR_HIGH;
reg EN_MDR_LOW;
reg [1:0] EXTENSION_MODE;
reg FIRST;
reg MEM_RWN;
reg MEM_START;
reg PC_INCREASE;
reg PC_JMP;
reg REG_WRITE;
reg SEL_ALU_IN1;
reg [1:0] SEL_ALU_IN2;
reg SEL_IN_A;
reg SEL_IN_B;
reg SEL_JMP;
reg [1:0] SEL_MEM_ADDR;
reg SEL_MEM_DATA;
reg SEL_REG_WRITE;
reg [2:0] SEL_REG_WRITE_DATA;
// wires                                               
wire EQUAL;
wire Mem_Ready;
wire [15:0] OP_CODE;

// assign statements (if any)                          
testing_DP i1 (
// port map - connection between master ports and signals/registers   
	.ALU_OP(ALU_OP),
	.CLK(CLK),
	.CLR(CLR),
	.EN_A(EN_A),
	.EN_ALUOUT(EN_ALUOUT),
	.EN_B(EN_B),
	.EN_HIGH(EN_HIGH),
	.EN_IR_HIGH(EN_IR_HIGH),
	.EN_IR_LOW(EN_IR_LOW),
	.EN_LOW(EN_LOW),
	.EN_MDR_HIGH(EN_MDR_HIGH),
	.EN_MDR_LOW(EN_MDR_LOW),
	.EQUAL(EQUAL),
	.EXTENSION_MODE(EXTENSION_MODE),
	.FIRST(FIRST),
	.Mem_Ready(Mem_Ready),
	.MEM_RWN(MEM_RWN),
	.MEM_START(MEM_START),
	.OP_CODE(OP_CODE),
	.PC_INCREASE(PC_INCREASE),
	.PC_JMP(PC_JMP),
	.REG_WRITE(REG_WRITE),
	.SEL_ALU_IN1(SEL_ALU_IN1),
	.SEL_ALU_IN2(SEL_ALU_IN2),
	.SEL_IN_A(SEL_IN_A),
	.SEL_IN_B(SEL_IN_B),
	.SEL_JMP(SEL_JMP),
	.SEL_MEM_ADDR(SEL_MEM_ADDR),
	.SEL_MEM_DATA(SEL_MEM_DATA),
	.SEL_REG_WRITE(SEL_REG_WRITE),
	.SEL_REG_WRITE_DATA(SEL_REG_WRITE_DATA)
);
initial 
begin 
#1000000 $finish;
end 
// ALU_OP[ 2 ]
initial
begin
	ALU_OP[2] = 1'b0;
end 
// ALU_OP[ 1 ]
initial
begin
	ALU_OP[1] = 1'b0;
end 
// ALU_OP[ 0 ]
initial
begin
	ALU_OP[0] = 1'b0;
end 

// CLK
always
begin
	CLK = 1'b0;
	CLK = #5000 1'b1;
	#5000;
end 

// CLR
initial
begin
	CLR = 1'b0;
end 

// EN_A
initial
begin
	EN_A = 1'b0;
end 

// EN_ALUOUT
initial
begin
	EN_ALUOUT = 1'b0;
end 

// EN_B
initial
begin
	EN_B = 1'b0;
end 

// EN_HIGH
initial
begin
	EN_HIGH = 1'b0;
end 

// EN_IR_HIGH
initial
begin
	EN_IR_HIGH = 1'b0;
	EN_IR_HIGH = #10000 1'b1;
	EN_IR_HIGH = #10000 1'b0;
end 

// EN_IR_LOW
initial
begin
	EN_IR_LOW = 1'b0;
end 

// EN_LOW
initial
begin
	EN_LOW = 1'b0;
end 

// EN_MDR_HIGH
initial
begin
	EN_MDR_HIGH = 1'b0;
end 

// EN_MDR_LOW
initial
begin
	EN_MDR_LOW = 1'b0;
end 
// EXTENSION_MODE[ 1 ]
initial
begin
	EXTENSION_MODE[1] = 1'b0;
end 
// EXTENSION_MODE[ 0 ]
initial
begin
	EXTENSION_MODE[0] = 1'b0;
end 

// MEM_RWN
initial
begin
	MEM_RWN = 1'b1;
	MEM_RWN = #20000 1'b0;
end 

// MEM_START
initial
begin
	MEM_START = 1'b1;
	MEM_START = #20000 1'b0;
end 

// PC_INCREASE
initial
begin
	PC_INCREASE = 1'b0;
end 

// PC_JMP
initial
begin
	PC_JMP = 1'b0;
end 

// REG_WRITE
initial
begin
	REG_WRITE = 1'b0;
end 

// SEL_ALU_IN1
initial
begin
	SEL_ALU_IN1 = 1'b0;
end 
// SEL_ALU_IN2[ 1 ]
initial
begin
	SEL_ALU_IN2[1] = 1'b0;
end 
// SEL_ALU_IN2[ 0 ]
initial
begin
	SEL_ALU_IN2[0] = 1'b0;
end 

// SEL_IN_A
initial
begin
	SEL_IN_A = 1'b0;
end 

// SEL_IN_B
initial
begin
	SEL_IN_B = 1'b0;
end 

// SEL_JMP
initial
begin
	SEL_JMP = 1'b0;
end 
// SEL_MEM_ADDR[ 1 ]
initial
begin
	SEL_MEM_ADDR[1] = 1'b1;
	SEL_MEM_ADDR[1] = #20000 1'b0;
end 
// SEL_MEM_ADDR[ 0 ]
initial
begin
	SEL_MEM_ADDR[0] = 1'b1;
	SEL_MEM_ADDR[0] = #20000 1'b0;
end 

// SEL_MEM_DATA
initial
begin
	SEL_MEM_DATA = 1'b0;
end 

// SEL_REG_WRITE
initial
begin
	SEL_REG_WRITE = 1'b0;
end 
// SEL_REG_WRITE_DATA[ 2 ]
initial
begin
	SEL_REG_WRITE_DATA[2] = 1'b0;
end 
// SEL_REG_WRITE_DATA[ 1 ]
initial
begin
	SEL_REG_WRITE_DATA[1] = 1'b0;
end 
// SEL_REG_WRITE_DATA[ 0 ]
initial
begin
	SEL_REG_WRITE_DATA[0] = 1'b0;
end 

// FIRST
initial
begin
	FIRST = 1'b1;
	FIRST = #10000 1'b0;
end 
endmodule

